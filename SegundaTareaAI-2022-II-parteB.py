# -*- coding: utf-8 -*-
"""Tarea2ParteBPYMOO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/176qXWK88vJ7O3weWhQDx54mplUh_mIlM

## Librerías
"""

pip install -U pymoo

#Useful packages
import autograd.numpy as anp
import matplotlib.pyplot as plt

#Problem classes
from pymoo.core.problem import Problem, ElementwiseProblem
from pymoo.problems.functional import FunctionalProblem
from pymoo.optimize import minimize

#Algorithms
#from pymoode.algorithms import GDE3
#from pymoode.algorithms import NSDE
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.algorithms.moo.nsga3 import NSGA3
from pymoo.factory import get_sampling, get_crossover, get_mutation
#Termination
from pymoo.termination.default import DefaultMultiObjectiveTermination
#Visualizacion
from pymoo.visualization.scatter import Scatter

"""## Estructura del problema

"""

class ProblemF2(Problem):
  #codificacion de la solucion al problema, aca se incluyen las restricciones
    def __init__(self):
      super().__init__(n_var=2, #se tienen 2 variables
                       n_obj=3, #se tienen 3 obejtivos
                       n_constr=0, # no hay ecuaciones con constraints
                       xl=anp.array([0, 0.8]), #rlimites inferiores para las variables
                       xu=anp.array([anp.pi, 2.5]), #limites superiores para las variables
                       elementwise_evaluation=True,
                       type_var=float)
    def _evaluate(self, x, out, *args, **kwargs):
      #x[:,0]: anfulo alfa 
      #x[:,1]: radio r
      #Funciones objetivo
        F1 = (2000/3)*anp.sqrt((9*anp.sin(x[:, 0])/x[:, 1])**2 + (1 + (9*anp.cos(x[:, 0]))/(x[:, 1]))**2)
        F2 = (2000/3)*anp.sqrt((9*anp.sin(x[:, 0]+(anp.pi*2/3))/x[:, 1])**2 + (1 + (9*anp.cos(x[:, 0]+(anp.pi*2/3)))/(x[:, 1]))**2)
        F3 = (2000/3)*anp.sqrt((9*anp.sin(x[:, 0]+(anp.pi*4/3))/x[:, 1])**2 + (1 + (9*anp.cos(x[:, 0]+(anp.pi*4/3)))/(x[:, 1]))**2)
        out["F"] = anp.column_stack([F1, F2, F3])

problem = ProblemF2()

"""### NSGA2"""

#Librerias necesarias para trabajar con el algoritmo
from pymoo.core.problem import Problem
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.util import plotting
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.selection.tournament import TournamentSelection
from pymoo.operators.crossover.pntx import SinglePointCrossover
from pymoo.operators.crossover.ux import UniformCrossover

algorithm = NSGA2 (
    pop_size=80, #tamano de la poblacion inicial
    n_offsprings=40, #cantidad de descendientes
    sampling=FloatRandomSampling(),
    crossover = SBX(prob=0.7, eta=20), #UniformCrossover(prob=1.0), # #SinglePointCrossover(prob=1.0), #tipos de recombinacion 
    mutation=PolynomialMutation(prob=0.2, eta=1), #mutacion utilizada
    eliminate_duplicates=True #eliminacion de individuos identicos, para dejar unicamente uno
)

"""### Optimizacion """

from pymoo.optimize import minimize
#inicializacion del problema de minimizacion 
#instanciamiento del algoritmo y su condicion de parada: 'n_gen',100
res = minimize(ProblemF2(),
               algorithm,
               ('n_gen',100),
               seed=1,
               save_history=True,
               verbose=True)
pop = res.pop

#X: cromosomas de la solucion 
X = res.X
#F: soluciones a las funciones objetivo 
F = res.F

#Frente de Pareto en 3D
Scatter().add(res.F).show()

from pymoo.visualization.heatmap import Heatmap
#Heatmap para visualizacion de las soluciones
plot = Heatmap(figsize=(30,30),
               #bound=[0,1],
               order_by_objectives=0,
               y_labels=None,
               labels=["F1", "F2", "F3"],
               cmap="Greens_r")

plot.add(F, aspect=0.2)
plot.show()

"""### Arreglo de los datos
A continuación se redondean los valores para que sean de un unico decimal, y se pasan los ángulos de radianes a grados.

"""

#Pasar de radianes a grados:
X[:, 0] = X[:, 0]*360/(2*anp.pi)
#Redondeo de las soluciones
X[:, 0]=anp.round(X[:, 0], decimals = 1)
X[:, 1]=anp.round(X[:, 1], decimals = 3)
F=anp.round(F, decimals = 2)

#X

#F

"""### Valores hallados para alfa y r"""

xl, xu = problem.bounds()

# Crea múltiples subgrafos
fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(12,12))

#Soluciones de a y r
ax[0, 0].scatter(X[:, 0], X[:, 1], s=30, facecolors='none', edgecolors='darkmagenta')
#ax[0, 0].set_xlim(xl[0], xu[0])
#ax[0, 0].set_ylim(xl[1], xu[1])
ax[0, 0].set_title("Espacio de soluciones")
ax[0, 0].set_xlabel('Valores de a (grados)')
ax[0, 0].set_ylabel('Valores de r (inches)')
ax[0, 0].grid(True)


#Valores de F1 vs F2
ax[0, 1].scatter(F[:, 0], F[:, 1], s=30, facecolors='none', edgecolors='olivedrab')
ax[0, 1].set_title("Frente de pareto F1 vs F2")
ax[0, 1].set_xlabel('F1 (lb)')
ax[0, 1].set_ylabel('F2 (lb)')
ax[0, 1].grid(True)

#Valores de F2 vs F3
ax[1, 0].scatter(F[:, 1], F[:, 2], s=30, facecolors='none', edgecolors='teal')
ax[1, 0].set_title("Frente de pareto F2 vs F3")
ax[1, 0].set_xlabel('F2 (lb)')
ax[1, 0].set_ylabel('F3 (lb)')
ax[1, 0].grid(True)

#Valores de F3 vs F1
ax[1, 1].scatter(F[:, 0], F[:, 2], s=30, facecolors='none', edgecolors='crimson')
ax[1, 1].set_title("Frente de pareto F3 vs F1")
ax[1, 1].set_xlabel('F1 (lb)')
ax[1, 1].set_ylabel('F3 (lb)')
ax[1, 1].grid(True)

plt.suptitle("Comparaciones NSGA2")
plt.show()

"""### Soluciones para verificar
En esta seccion se eligen que soluciones se desean ver
"""

soluciones = anp.fromstring(input('Ingrese las soluciones que desea ver separadas por un espacio (si desea ver todas indiquelo ingresando la palabra "todas"): '), dtype=int, sep=' ')

for x in soluciones:
  print(f"\nSolucion {x}: \t valor del angulo: {X[x-1, 0]} grados \t valor del radio: {X[x-1, 1]} in \
   \t F1: {F[x-1, 0]} lb, F2: {F[x-1, 1]} lb, F3: {F[x-1, 2]} lb \t \
  suma total = {F[x-1, 0]+F[x-1, 1]+F[x-1, 2]} lb \t resta total = {F[x-1, 0]-F[x-1, 1]-F[x-1, 2]} lb\n")

"""

---

"""